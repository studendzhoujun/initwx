/*
 * @Author: liuxiaocong 
 * @Date: 2017-07-31 17:18:50 
 * @Last Modified by: liuxiaocong
 * @Last Modified time: 2017-08-06 20:30:47
 */
//事件通道
// import utils from './utils'
var utils = require('./utils')
let nextGuid = 1
const Channel = function(type, sticky) {
            this.type = type;
            // Map of guid -> function. 
            this.handlers = {};
            // 0 = Non-sticky, 1 = Sticky non-fired, 2 = Sticky fired.
            this.state = sticky ? 1 : 0;
            // Used in sticky mode to remember args passed to fire().
            this.fireArgs = null;
            // Used by onHasSubscribersChange to know if there are any listeners.
            this.numHandlers = 0;
            // Function that is called when the first listener is subscribed, or when
            // the last listener is unsubscribed.
            this.onHasSubscribersChange = null;
        }
let channel = {
    // 把指定的函数h订阅到c的各个通道上，保证h在每个通道的最后被执行  
    join: function(h, c) {
        var len = c.length,
        i = len,
        f = function() {
            if (! (--i)) h();
        };
        for (var j = 0; j < len; j++) {
            if (c[j].state === 0) {
                throw Error('Can only use join with sticky channels.');
            }
            c[j].subscribe(f);
        }
        if (!len) h();
    },
    create: function(type) {
        return channel[type] = new Channel(type, false);
    },
    createSticky: function(type) {
        return channel[type] = new Channel(type, true);
    },
    // 保存deviceready事件之前要调用的事件
    deviceReadyChannelsArray: [],
    deviceReadyChannelsMap: {},
    // 设置deviceready事件之前必须要完成的事件  
    waitForInitialization: function(feature) {
        if (feature) {
            var c = channel[feature] || this.createSticky(feature);
            this.deviceReadyChannelsMap[feature] = c;
            this.deviceReadyChannelsArray.push(c);
        }
    }
};
// 这个应该放入utils里，就是一个函数的判断  
function forceFunction(f) {
    if (typeof f != 'function') throw "Function required as first argument!";
}
// ③修改函数原型共享实例方法-----------------------  
// 向事件通道订阅事件处理函数(subscribe部分）  
// f:事件处理函数 c:事件的上下文（可省略）  
Channel.prototype.subscribe = function(f, c) {
    // need a function to call
    forceFunction(f);
    if (this.state == 2) {
        f.apply(c || this, this.fireArgs);
        return;
    }

    var func = f,
    guid = f.observer_guid;
    if (typeof c == "object") {
        func = utils.close(c, f);
    }

    if (!guid) {
        // first time any channel has seen this subscriber
        guid = '' + nextGuid++;
    }
    func.observer_guid = guid;
    f.observer_guid = guid;

    // Don't add the same handler more than once.
    if (!this.handlers[guid]) {
        this.handlers[guid] = func;
        this.numHandlers++;
        if (this.numHandlers == 1) {
            this.onHasSubscribersChange && this.onHasSubscribersChange();
        }
    }
};
// 撤消订阅通道上的某个函数（guid）
Channel.prototype.unsubscribe = function(f) {
    // need a function to unsubscribe
    forceFunction(f);

    var guid = f.observer_guid,
    handler = this.handlers[guid];
    if (handler) {
        delete this.handlers[guid];
        this.numHandlers--;
        if (this.numHandlers === 0) {
            this.onHasSubscribersChange && this.onHasSubscribersChange();
        }
    }
};
// 调用所有被发布到该通道上的函数 
Channel.prototype.fire = function(e) {
    var fail = false,
    fireArgs = Array.prototype.slice.call(arguments);
    // Apply stickiness.
    if (this.state == 1) {
        this.state = 2;
        this.fireArgs = fireArgs;
    }
    if (this.numHandlers) {
        // Copy the values first so that it is safe to modify it from within
        // callbacks.
        var toCall = [];
        for (var item in this.handlers) {
            toCall.push(this.handlers[item]);
        }
        for (var i = 0; i < toCall.length; ++i) {
            toCall[i].apply(this, fireArgs);
        }
        if (this.state == 2 && this.numHandlers) {
            this.numHandlers = 0;
            this.handlers = {};
            this.onHasSubscribersChange && this.onHasSubscribersChange();
        }
    }
};
// ④创建事件通道（publish部分）-----------------------  
// （内部事件通道）页面加载后DOM解析完成  
channel.createSticky('onDOMContentLoaded');
channel.createSticky('onNativeReady');
// （内部事件通道）所有Cordova的JavaScript对象被创建完成可以开始加载插件 
channel.createSticky('onCordovaReady');
// Cordova全部准备完成  
channel.createSticky('onDeviceReady');
channel.create('onResume');
channel.create('onPause');
// ⑤设置deviceready事件之前必须要完成的事件  
// ***onNativeReady和onPluginsReady是平台初期化之前要完成的。  
channel.waitForInitialization('onCordovaReady');
channel.waitForInitialization('onDOMContentLoaded');
module.exports = channel
// export  {channel}